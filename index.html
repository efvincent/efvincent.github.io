<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Curried Functions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="My Personal Blog about Computer Science (mostly) and other personal interests">
<meta property="og:type" content="website">
<meta property="og:title" content="Curried Functions">
<meta property="og:url" content="http://efvincent.github.io/">
<meta property="og:site_name" content="Curried Functions">
<meta property="og:description" content="My Personal Blog about Computer Science (mostly) and other personal interests">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Eric Vincent">
<meta property="article:tag" content="computer-science functional-programming">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Curried Functions" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer" style="background-color: #353333;">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Curried Functions</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Who likes to code</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://efvincent.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-230217-Haskell-Basics-04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/230217-Haskell-Basics-04/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T06:00:00.000Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/haskell/">haskell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/03/09/230217-Haskell-Basics-04/">Haskell Basics - Lists &amp; Functions 03</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>In the <a href="/2023/02/11/230210-Haskell-Basics-03/" title="Haskell Basics - Lists &amp; Functions 02">last post</a> we explored the definition of functions by defining a function that returns <code>Yep</code> (our own boolean definition, <code>Booly</code>) if we pass it an empty list (using our own list definition: <code>Lst</code>). Here's the code with which we were working, and that we'll expand upon in this post. A friend of mine let me know about the Haskell Playground; I've added this as a <a target="_blank" rel="noopener" href="https://play.haskell.org/saved/s6dxVzd1">snippet on the playground</a>, I'll try to add all my samples over there and see how it works out.</p>
<figure class="highlight haskell"><figcaption><span>picking up from last time</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> List230217 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | The Prelude defines the most common data types and functions for</span></span><br><span class="line"><span class="comment">-- | us, but the LANGUAGE construct at the top of the page excludes the</span></span><br><span class="line"><span class="comment">-- | normally automatically imported Prelude. Here we add back in what</span></span><br><span class="line"><span class="comment">-- | we might need in this module.</span></span><br><span class="line"><span class="keyword">import</span> Prelude (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | our own version of a list datatype</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a </span></span><br><span class="line">  = <span class="type">NIL</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | our own version of a boolean datatype</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Booly</span></span></span><br><span class="line">  = <span class="type">Yep</span></span><br><span class="line">  | <span class="type">Nope</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Returns true if an instance of @Lst@ is empty, false otherwise</span></span><br><span class="line"><span class="title">isEmpty</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty</span> <span class="type">NIL</span> = <span class="type">Yep</span></span><br><span class="line"><span class="title">isEmpty</span> _   = <span class="type">Nope</span></span><br></pre></td></tr></table></figure>
<h2 id="list-length">List Length</h2>
<p>Next function we'll tackle is finding the length of a list. Most (dare I say all) languages have a function to find the length of a list (or array, or vector, etc.), Haskell included. We, however, have been intentionally <em>excluded</em> <code>Prelude</code>, Haskell's standard library, and we've been re-inventing the wheel by defining our own list and boolean types for the purpose of understanding how these fundamental types work.</p>
<h3 id="recursive-functions-and-inductive-data-types">Recursive Functions and Inductive Data Types</h3>
<p>You'll recall that our definition for lists is an <em>inductive</em> data type with two constructors, the <code>NIL</code> constructor that represents an empty list, and the <code>Cons a (Lst a)</code> constructor, which represents one element of the list and the rest of the list. When a sum type has one constructor that refers to it's own type (<code>Cons</code> has a reference to <code>Lst</code>), you should recognize it as an inductive type definition.</p>
<p>Inductive types and recursive functions are two sides of the same coin. The natural way to enumerate an inductive data type such as this is with a recursive function. Just like an inductive definition starts with a <em>base case</em>, which for our list definition is <code>NIL</code>, the same is true of the recursive function we use to manipulate it. This is a function for calculating the length of a list.</p>
<figure class="highlight haskell"><figcaption><span>Length of a List</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| An example list of integers 1 - 4 -&#125;</span></span><br><span class="line"><span class="title">ex01</span> :: <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ex01</span> = <span class="type">Cons</span> <span class="number">1</span> (<span class="type">Cons</span> <span class="number">2</span> (<span class="type">Cons</span> <span class="number">3</span> (<span class="type">Cons</span> <span class="number">4</span> <span class="type">NIL</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Compute the length of a list as an integer -&#125;</span></span><br><span class="line"><span class="title">lstLen</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">lstLen</span> <span class="type">NIL</span> = <span class="number">0</span></span><br><span class="line"><span class="title">lstLen</span> (<span class="type">Cons</span> x xs) = <span class="number">1</span> + lstLen xs</span><br></pre></td></tr></table></figure>
<p>(<a target="_blank" rel="noopener" href="https://play.haskell.org/saved/al4dQ9oc">snippet</a> in the playground)</p>
<p>You remember that the first line of the function is the type declaration <code>lstLen :: Lst a -&gt; Int</code>. This tells us that that function has one parameter of type <code>Lst a</code>, where the <code>a</code> is a type variable meaning this will work with lists of any type.</p>
<p>The base case for the recursive function <code>lstLen</code> handles the case when the list (which is the only parameter) is <code>NIL</code>. When the list is <code>NIL</code>, the length is zero, because it's the empty list. The recursive case matches a list that is <code>(Cons x xs)</code>, this will match any non-empty list. You'll notice our matching case binds variables <code>x</code> and <code>xs</code>. Get used to this syntax, it's <strong>super</strong> common, and Haskell has robust pattern matching and binding.</p>
<p>The <code>x</code> in the <code>Cons</code> case is the first item in the list, and the <code>xs</code> is the rest of the list. Note that the rest of the list is another list. We can say verbally that the <code>Cons</code> is an item in the list and another list. The "another list" may be another <code>Cons</code> , which would be the head of <em>that</em> list and another list. And so on, until we get to a <code>Nil</code>, which is the empty list.</p>
<p>To calculate the length of the list, when we get to a <code>Cons</code>, we'll say that the length of the list is one, plus whatever the length of the rest of the list is. In effect, our <code>lstLen</code> function replaces all the <code>Cons</code> that are chained together with a <code>1 +</code> and it replaces the <code>NIL</code> with zero:</p>
<figure class="highlight text"><figcaption><span>From List to Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Cons 1 (Cons 2 (Cons 3 (Cons 4 NIL))))  -- ex01</span><br><span class="line">(1 +    (1 +    (1 +    (1 +    0  ))))  -- lstLen ex01</span><br></pre></td></tr></table></figure>
<p>The relationship of the inductive type to the recursive function is obvious! You'll see this pattern over and over again, as inductive types are fundamental to many functional data structures, and many functional languages (Haskell included) don't even have constructs like for loops. In Haskell, when you have to loop, you have to use recursion. If you're familiar with functions like <code>map</code> and <code>fold</code> you might say "hey wait - I don't <em>have</em> to use recursion, I can use functions like <code>map</code> and <code>fold</code> " ... well that's true but map and fold are recursive functions, so you may not have to <em>write</em> recursive functions, but you will definitely <em>use</em> recursive functions ;)</p>
<h3 id="double-every-list-item">Double Every List Item</h3>
<p>Now rather than counting every list item, we're going to <em>modify</em> each item in a list of integers by doubling it. But Haskell is immutable, so we can't change existing values. Whenever you want to "change" the value of a variable you have to instead think of creating a new variable with the new value.</p>
<figure class="highlight haskell"><figcaption><span>Double Every Item</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Double every item in the list -&#125;</span></span><br><span class="line"><span class="title">doubler</span> :: <span class="type">Lst</span> <span class="type">Int</span> -&gt; <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">doubler</span> <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">doubler</span> (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (x * <span class="number">2</span>) (doubler xs)</span><br></pre></td></tr></table></figure>
<p>(<a target="_blank" rel="noopener" href="https://play.haskell.org/saved/Wtw54h4Y">snippet</a> in playground)</p>
<p>The <code>doubler</code> function follows the same pattern as <code>lstLen</code>. We handle the base case of the inductive type <code>Lst</code> by pattern matching <code>NIL</code>. Doubling every value in the empty list results in the empty list, no surprise there. The inductive case matches against <code>Cons x xs</code>, with the head of the list bound to <code>x</code> and the rest of the list is <code>xs</code>. The result of this match is a <em>new</em> <code>Cons</code>, with the head of the list being doubled, and calling <code>doubler</code> recursively on <code>xs</code> to get the new rest of the list.</p>
<p>Much like <code>lstLen</code>, the <code>doubler</code> function replaces each <code>Cons</code> as it walks its way down the list.</p>
<figure class="highlight text"><figcaption><span>From List to Modified List</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Cons 1       (Cons 2       (Cons 3       (Cons 4       NIL))))  -- ex01</span><br><span class="line">(1 +          (1 +          (1 +          (1 +          0  ))))  -- lstLen ex01</span><br><span class="line"></span><br><span class="line">(Cons (1 * 2) (Cons (2 * 2) (Cons (3 * 2) (Cons (4 * 2) NIL))))  -- doubler ex01</span><br></pre></td></tr></table></figure>
<h3 id="generalizing-with-map-and-fold">Generalizing with Map and Fold</h3>
<p>You may recognize the <code>doubler</code> as doing a <em>map</em> operation, and our <code>lstLen</code> is doing a <em>fold</em>. Let's start with a map operation.</p>
<h4 id="map">Map</h4>
<p>When we want to apply a function, for example one that double's an integer, to every item in a list (or other collection as we'll see), we can write the function directly as we did with <code>doubler</code>, or we can use a <em>higher order function</em> called map. A <strong>higher-order function</strong> is one that either takes a function as an argument, returns a function, or both. It's a function that operates on functions.</p>
<p><code>doubler</code> is a function that doubles every element of a list. If we just look at the doubling part of <code>doubler</code>, we have</p>
<figure class="highlight haskell"><figcaption><span>double an integer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Doubles the input parameter -&#125;</span></span><br><span class="line"><span class="title">dub</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">dub</span> n = n * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>We can rewrite <code>doubler</code> using this function:</p>
<figure class="highlight haskell"><figcaption><span>doubler using dub</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Double every item in the list using dub -&#125;</span></span><br><span class="line"><span class="title">doubler</span> :: <span class="type">Lst</span> <span class="type">Int</span> -&gt; <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">doubler</span> <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">doubler</span> (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (dub x) (doubler xs)</span><br></pre></td></tr></table></figure>
<p>Now we can see how we might be able to generalize this function, if we pass the <code>dub</code> function in as a parameter. We'll change the name of the function as now it could do other things to every value in the list. Note how we specify the type of the modifying function; it's the same type signature of our <code>dub</code> function.</p>
<figure class="highlight haskell"><figcaption><span>Generalized list modifier</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Apply a function to every element in the list to generate</span></span><br><span class="line"><span class="comment">    a new element -&#125;</span></span><br><span class="line"><span class="title">lstModder</span> :: (<span class="type">Int</span> -&gt; <span class="type">Int</span>) -&gt; <span class="type">Lst</span> <span class="type">Int</span> -&gt; <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">lstModder</span> _ <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">lstModder</span> modFn (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (modFn x) (lstModder modFn xs)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Output list and doubled list -&#125;</span></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ <span class="string">&quot;ex1         : &quot;</span> ++ (show ex01) </span><br><span class="line">  putStrLn $ <span class="string">&quot;doubled ex1 : &quot;</span> ++ (show (lstModder dub ex01))</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/rIqKIt7i">Snippet</a></p>
<p>The first parameter is a function from <code>Int</code> to <code>Int</code>. We pass our integer doubling function <code>dub</code> to the <code>lstModder</code> function to do the work of modifying each element. Note how in the base case, when the list is <code>NIL</code> (empty), we use an underscore in the place of the first parameter. This tells Haskell to ignore the first parameter. In an empty list, we won't be using the modifier function. We could still name it, but Haskell would then warn us we have an unused variable.</p>
<p>The parentheses in the type signature are necessary because the arrow <code>-&gt;</code> which defines a function, binds to the right. That means without parentheses the order of precedence would look like the following, and the function would not type check. It would be expecting three parameters first and second parameters to be a <code>Int</code>s and the third an <code>Lst Int</code>.</p>
<figure class="highlight haskell"><figcaption><span>wrong order of precedence</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| does not type check -&#125;</span></span><br><span class="line"><span class="title">lstModder</span> :: (<span class="type">Int</span> -&gt; (<span class="type">Int</span> -&gt; (<span class="type">Lst</span> <span class="type">Int</span> -&gt; <span class="type">Lst</span> <span class="type">Int</span>)))</span><br><span class="line"><span class="title">lstModder</span> _ <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">lstModder</span> modFn (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (modFn x) (lstModder modFn xs)</span><br></pre></td></tr></table></figure>
<p>Now we have a general purpose modifier for lists of <em>integers</em>, but we could generalize further. What if we didn't specify <code>Int</code> as the input and output of our modifier function. And even better, what if the input and output of the modifier function didn't have to both be the same type?</p>
<figure class="highlight haskell"><figcaption><span>general purpose lst modder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| apply a modifier function to a list of any type -&#125;</span></span><br><span class="line"><span class="title">lstModder</span> :: (a -&gt; b) -&gt; <span class="type">Lst</span> a -&gt; <span class="type">Lst</span> b</span><br><span class="line"><span class="title">lstModder</span> _ <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">lstModder</span> modFn (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (modFn x) (lstModder modFn xs)</span><br></pre></td></tr></table></figure>
<p>We've already seen a <em>type variable</em> used in the definition of <code>Lst</code> to enable the <code>Lst</code> inductive type to represent a list of any type. The same approach is used in the <code>lstModder</code> function, the lower case <code>a</code> and <code>b</code> can both represent any type, without restriction. The implication is that the modifier function can not only modify one of the elements of the list, it can return a completely different type! The modifier turns a single <code>a</code> into a <code>b</code>, and the <code>lstModder</code> turns a <em>list of</em> <code>a</code> into a <em>list of</em> <code>b</code>. It could be that <code>a</code> and <code>b</code> are the same type as they are in the <code>dub</code> function, but they can also be different.</p>
<p>It happens now that our list modifier function is exactly a <strong>map</strong> function for our <code>Lst</code> data type.</p>
<figure class="highlight haskell"><figcaption><span>list modder is map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Apply a function to eeach element in a list </span></span><br><span class="line"><span class="comment">    to produce a new list -&#125;</span></span><br><span class="line"><span class="title">lstMap</span> :: (a -&gt; b) -&gt; <span class="type">Lst</span> a -&gt; <span class="type">Lst</span> b</span><br><span class="line"><span class="title">lstMap</span> _ <span class="type">NIL</span>         = <span class="type">NIL</span></span><br><span class="line"><span class="title">lstMap</span> f (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (f x) (lstMap f xs)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/QyPA1efd">Snippet</a></p>
<p>We can use our new <code>lstMap</code> with a different modifier function to create a sort of a histogram:</p>
<figure class="highlight haskell"><figcaption><span>from a list of ints to a histogram</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Makes a string of repeated strings -&#125;</span></span><br><span class="line"><span class="title">makeStringOf</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">makeStringOf</span> _ <span class="number">0</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title">makeStringOf</span> s n = s ++ (makeStringOf s (n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Makes a string of asterisks -&#125;</span></span><br><span class="line"><span class="title">makeStringOfStars</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">makeStringOfStars</span> n = makeStringOf <span class="string">&quot;*&quot;</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Turn a list of integers to a list of strings of asterisks where</span></span><br><span class="line"><span class="comment">    each string of asterisks represents the integer from the </span></span><br><span class="line"><span class="comment">    original list -&#125;</span></span><br><span class="line"><span class="title">histogramOf</span> :: <span class="type">Lst</span> <span class="type">Int</span> -&gt; <span class="type">Lst</span> <span class="type">String</span></span><br><span class="line"><span class="title">histogramOf</span> nums = lstMap makeStringOfStars nums</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/q4ihdfWk">Snippet</a></p>
<p>Let's introduce a couple of more concepts that you'd find in real Haskell code before moving on. Here's another way to produce our histogram.</p>
<figure class="highlight haskell"><figcaption><span>another way to histogram</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> $ show $ lstMap (makeStringOf <span class="string">&quot;*&quot;</span>) ex01</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/iSchmZYf">Snippet</a></p>
<p>There are a few different things going on here. First, the <code>putStrLn $ show $</code> (look at the <a target="_blank" rel="noopener" href="https://play.haskell.org/saved/iSchmZYf">snippet</a> for the full context) - this is just a way to print our result to the output, we'll look at the details later. More interestingly, we've gotten rid of <code>mkeStringOfStars</code>. The type of <code>makeStringOf</code> is <code>String -&gt; Int -&gt; String</code>. In Haskell, if we pass this function that expects 2 parameters just one, what would it return?</p>
<figure class="highlight text"><figcaption><span>curried function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">makeStringOf :: String -&gt; Int -&gt; String</span><br><span class="line">                 🡡         \__________/</span><br><span class="line">                 |               |</span><br><span class="line">                 |               |</span><br><span class="line">makeStringOf    &quot;*&quot;              |</span><br><span class="line">                                 |</span><br><span class="line">                                 🡣</span><br><span class="line">                          /-----------\</span><br><span class="line">                          Int -&gt; String</span><br></pre></td></tr></table></figure>
<p>What we get back is another function, this time <code>Int -&gt; String</code>. The asterisk string we pass to <code>makeStringOf</code> is <em>captured</em> in this new function that is returned. The new function will turn any <code>Int</code> into a string of that many asterisks. We then pass this in our <code>lstMap</code> function as the modifier. This behavior is known as <em>partial application</em>, we're only partially applying the parameters the <code>makeStringOf</code> function is expecting. This is perfectly legal and canonical Haskell.</p>
<h4 id="fold">Fold</h4>
<p>While a map function is definitely a powerful tool, it is limited in that the structure being mapped over, a list in our case, is preserved in the output. Map doesn't allow us to change the output type. It will not only be a list, but be a list of the same size. What we need is a similar function that walks the data structure and allows more flexibility. Let's use this to refactor our <code>lstLen</code> function for finding the length of a list.</p>
<figure class="highlight haskell"><figcaption><span>fold for our list type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-| Fold for Lst -&#125;</span></span><br><span class="line"><span class="title">lstFold</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <span class="type">Lst</span> a -&gt; b</span><br><span class="line"><span class="title">lstFold</span> _ acc <span class="type">NIL</span> = acc</span><br><span class="line"><span class="title">lstFold</span> f acc (<span class="type">Cons</span> x xs) = lstFold f (f acc x) xs</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Get the length of a list by folding over the list with</span></span><br><span class="line"><span class="comment">    an accumulator function -&#125;</span></span><br><span class="line"><span class="title">lstLen</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">lstLen</span> xs = lstFold (\acc _ -&gt; <span class="number">1</span> + acc) <span class="number">0</span> xs</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/lkigFcXR">Snippet</a></p>
<p>The type of <code>lstFold</code> is interesting. The first parenthesized parameter has type <code>(b -&gt; a -&gt; b)</code>. We saw earlier that the parentheses indicate that the first parameter is a function, in this case a function that takes two parameters <code>a</code> and <code>b</code>, and returns a value of the same type <code>b</code> as the first parameter. The first parameter, <code>b</code>, is usually referred to as the <em>accumulator</em>. This is the new value that we're building with our fold. Each application of <code>lstFold</code> will get the accumulator and the next value in the list. It should use these two parameters to calculate and return a new value for the accumulator.</p>
<p>The next parameter after the accumulator function is also of type <code>b</code>, and this should be the value of the accumulator <em>before we start processing the list</em>. When counting the elements in a list for example, we should start at zero as the accumulator. We need this because even at the first element, the accumulator function needs a value for the accumulator.</p>
<p>The last parameter to <code>lstFold</code> is the list over which we are folding.</p>
<p>The new <code>lstLen</code> function now uses <code>lstFold</code> and another new concept, an anonymous function, to calculate the length of the list. The anonymous function saves us from having to write a named function just to add one to a number. In Haskell an anonymous function begins with the backslash followed by the arguments of the function separated by spaces, and the body of the function follows the right arrow <code>-&gt;</code>.</p>
<figure class="highlight haskell"><figcaption><span>anonymous number</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- instead of</span></span><br><span class="line"><span class="title">add1ToX</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">add1ToX</span> acc _ = acc + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- we can use an anonymous function</span></span><br><span class="line">\acc _ -&gt; acc + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Note that in the case of counting the elements in the list, we don't actually care <em>what</em> the element is, so in our accumulator function we ignore the second parameter that <code>lstFold</code> is looking for, the element in the list. But if we wanted to say sum up the values in an integer list, we could do that with this call to <code>lstFold</code>. The accumulator is carrying the running sum through the list.</p>
<figure class="highlight haskell"><figcaption><span>sum the values in an integer list</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">putStrLn</span> $ show $ lstFold (\acc x -&gt; acc + x) <span class="number">0</span> ex01</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/6AGvoDnV">Snippet</a></p>
<h4 id="η-conversion">η-conversion</h4>
<p>There's another interesting optimization we can use, called  η-conversion, (eta conversion). This one is optional, and some people really don't care to see it in code, but it is a fundamental concept with which it is good to be comfortable. As a matter of fact, with the Visual Studio Code plugin, you'll get linter hints where there's an opportunity to use  η-conversion.</p>
<figure class="highlight haskell"><figcaption><span>beta reduction for lstLen</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&#123;-| before η-conversion -&#125;</span></span><br><span class="line"><span class="title">lstLen1</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">lstLen1</span> xs = lstFold (\acc _ -&gt; <span class="number">1</span> + acc) <span class="number">0</span> xs</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| with  η-conversion -&#125;</span></span><br><span class="line"><span class="title">lstLen</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">lstLen</span> = lstFold (\acc _ -&gt; <span class="number">1</span> + acc) <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Note that the type signature for <code>lstLen</code> hasn't changed, it's still looking for a <code>Lst a</code> and returning an <code>Int</code>. But in the definition, we've left off the parameter. We've also left the last parameter from body of the function, the call to <code>lstFold</code>. Look at this simple example:</p>
<figure class="highlight haskell"><figcaption><span>η-conversion</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- these two definitions are the same (assume an abs function exists):</span></span><br><span class="line"></span><br><span class="line"><span class="title">myAbs1</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">myAbs1</span> x = abs x</span><br><span class="line"></span><br><span class="line"><span class="title">myAbs2</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">myAbs2</span> = abs</span><br></pre></td></tr></table></figure>
<h4 id="partial-application-of-infix-operators">Partial Application of Infix Operators</h4>
<p>Another common technique is using partial application of infix operators. Remembering that addition and multiplication are actually functions with an <em>infix</em> syntax, which means the arguments of the function are placed on either side of the function:</p>
<figure class="highlight haskell"><figcaption><span>infix functions</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">add</span> a b = a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">-- these are equiv</span></span><br><span class="line"><span class="comment">-- note that you can&#x27;t redefine ans over and over, this is just an example</span></span><br><span class="line"></span><br><span class="line"><span class="title">ans</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ans</span> = <span class="number">2</span> + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="title">ans</span> = (+) <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="title">ans</span> = add <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="title">ans</span> = <span class="number">2</span> `add` <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>When we want to treat an infix operator, like addition, as a normal prefix function, we wrap it in parentheses. And when we want to treat a standard prefix function like <code>add</code> above as an <em>infix</em> function, we can wrap it in back ticks.</p>
<p>Knowing this, we can leverage partial application:</p>
<figure class="highlight haskell"><figcaption><span>partial application of infix operators</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Add 2 to every integer in a list -&#125;</span></span><br><span class="line"><span class="title">ans1</span> :: <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ans1</span> = lstMap (<span class="number">2</span> +) ex01</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| sum up every element in a list -&#125;</span></span><br><span class="line"><span class="title">ans2</span> :: <span class="type">Int</span></span><br><span class="line"><span class="title">ans2</span> = lstFold (+) <span class="number">0</span> ex01</span><br></pre></td></tr></table></figure>
<h2 id="wrapping-up">Wrapping up</h2>
<p>This is already a long post ... let's wrap it up by switching from the custom types we've been using for bools and lists to the standard ones from the Prelude, and using anonymous functions and η-conversion where we'd typically find them. Although there are standard functions for list length and sum, we'll still use our own.</p>
<p>On difference to notice when looking at this converted code - since Haskell uses lists so extensively, there's some syntactic sugar for added convenience. We can use square brackets in the type signature <code>[Int]</code> rather than <code>List Int</code>, we can use empty brackets <code>[]</code> rather than <code>NIL</code>, and we can use an infix operator <code>:</code> rather than <code>Cons</code>:</p>
<figure class="highlight haskell"><figcaption><span>list syntactic sugar</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----- Lst ------------------------------------ </span></span><br><span class="line"><span class="title">emptyLst</span> :: <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">emptyLst</span> = <span class="type">NIL</span></span><br><span class="line"></span><br><span class="line"><span class="title">ex01</span> :: <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">ex01</span> = (<span class="type">Cons</span> <span class="number">1</span> (<span class="type">Cons</span> <span class="number">2</span> (<span class="type">Cons</span> <span class="number">3</span> (<span class="type">Cons</span> <span class="number">4</span> <span class="type">NIL</span>))))</span><br><span class="line"></span><br><span class="line"><span class="title">mapLst</span> :: (a -&gt; b) -&gt; <span class="type">Lst</span> a -&gt; <span class="type">Lst</span> b</span><br><span class="line"><span class="title">mapLst</span> _ <span class="type">NIL</span> = <span class="type">NIL</span></span><br><span class="line"><span class="title">mapLst</span> f (<span class="type">Cons</span> x xs) = <span class="type">Cons</span> (f x) (map f xs)</span><br><span class="line"></span><br><span class="line"><span class="comment">----- List -----------------------------------</span></span><br><span class="line"><span class="title">emptyList</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">emptyList</span> = []</span><br><span class="line"></span><br><span class="line"><span class="title">ex01</span> = (<span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span> :: (<span class="number">4</span> :: []))))</span><br><span class="line"><span class="comment">-- or --</span></span><br><span class="line"><span class="title">ex01</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">mapList</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">mapList</span> _ [] = []</span><br><span class="line"><span class="title">mapList</span> f (x:xs) = (f x) : (map f xs)</span><br></pre></td></tr></table></figure>
<p>And finally, the final code listing, using the <code>List</code> type and other functions available in the Prelude.</p>
<figure class="highlight haskell"><figcaption><span>Exercises with built in types and functions</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Prelude </span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- Prelude has </span></span><br><span class="line"><span class="comment">     null :: [a] -&gt; Bool    that retunrs True for empty lists,</span></span><br><span class="line"><span class="comment">     length :: [a] -&gt; Int    to get the length of litss, and</span></span><br><span class="line"><span class="comment">     sum :: [Int] -&gt; Int to get the sum of elements in the list</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">  so these implementations could be simpler still -&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| An example list of integers 1 - 4 -&#125;</span></span><br><span class="line"><span class="title">ex01</span> :: [<span class="type">Int</span>]</span><br><span class="line"><span class="title">ex01</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;-| Makes a string of repeated strings -&#125;</span></span><br><span class="line"><span class="title">makeStringOf</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">makeStringOf</span> _ <span class="number">0</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="title">makeStringOf</span> s n = s ++ (makeStringOf s (n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">  putStrLn $ <span class="string">&quot;ex1         : &quot;</span> ++ (show ex01) </span><br><span class="line">  putStrLn $ <span class="string">&quot;ex1 length  : &quot;</span> ++ (show (foldl (\acc _ -&gt; acc + <span class="number">1</span>) <span class="number">0</span> ex01))</span><br><span class="line">  putStrLn $ <span class="string">&quot;doubled ex1 : &quot;</span> ++ (show (map (<span class="number">2</span> *) ex01))</span><br><span class="line">  putStrLn $ <span class="string">&quot;sum ex1     : &quot;</span> ++ (show (foldl (+) <span class="number">0</span> ex01))</span><br><span class="line">  putStrLn $ <span class="string">&quot;histogram   : &quot;</span> ++ (show (map (makeStringOf <span class="string">&quot;*&quot;</span>) ex01))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- bonus - mapping using foldr for a right fold...</span></span><br><span class="line">  putStrLn $ <span class="string">&quot;doubled ex1 : &quot;</span> ++</span><br><span class="line">    (show (foldr (\x acc -&gt; (<span class="number">2</span> * x):acc) [] ex01))</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://play.haskell.org/saved/rGLvoUcQ">Snippet</a></p>
<p>Even with as much as we've looked at, we're still exploring the very tippy tip of the iceberg of the Haskell language. We've only looked at lists, but I've hinted that functions like map and fold can work over other data structures as well, like trees for example. Exploring how a function like map or fold might work over different data structures will require exploring <em>type classes</em> - a topic we'll have to tackle in another (possibly series of) posts!</p>
<p>But don't be discouraged - with the information we've covered we can create most data structures, and most any function to manipulate these data structures, only missing some conveniences and abstractions that would make our code more concise and reusable, but no more correct. You've got the basic building blocks right now!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/03/09/230217-Haskell-Basics-04/" data-id="clf2y0gxk000aiwp5dfrv8fgt" data-title="Haskell Basics - Lists &amp; Functions 03" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/03/09/230217-Haskell-Basics-04/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functions/" rel="tag">functions</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-230210-Haskell-Basics-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/11/230210-Haskell-Basics-03/" class="article-date">
  <time class="dt-published" datetime="2023-02-11T10:00:00.000Z" itemprop="datePublished">2023-02-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/haskell/">haskell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/11/230210-Haskell-Basics-03/">Haskell Basics - Lists &amp; Functions 02</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Previously:</p>
<ul>
<li><a href="/2023/02/06/230206-Haskell-Basics-01/" title="Haskell Basics - Functions 01">Haskell Basics - Functions 01</a></li>
<li><a href="/2023/02/07/230207-Haskell-Basics-02/" title="Haskell Basics - Lists 01">Haskell Basics - Lists 01</a></li>
</ul>
<p>In recent posts, we've discussed <a href="/2023/02/07/230207-Haskell-Basics-02/" title="Haskell Basics - Lists 01">a list data type</a> and the <a href="/2023/02/06/230206-Haskell-Basics-01/" title="Haskell Basics - Functions 01">basics of function types</a>. Here's the list that we came up with last time (I've updated the module name for this post, but otherwise it's the same as last time). <figure class="highlight haskell"><figcaption><span>Lst Example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> List230210 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a</span></span><br><span class="line">  = <span class="type">NIL</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="functions-on-our-list-type">Functions on our List Type</h1>
<p>Now we'll combine topics of those two posts and write some of the common functions found that operate on lists, and in doing so, we'll come across several other important concepts in Haskell and in functional programming in general.</p>
<h2 id="is-the-list-empty">Is the List Empty?</h2>
<p>Determining whether or not a list is empty is perhaps the simplest possible list function. When programming in Haskell one approach is to write the signature of the function. Believe it or not, in many simple cases, there's only one way to write a function for a given signature. <figure class="highlight haskell"><figcaption><span>Signature of isEmpty</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isEmpty</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure></p>
<p>We're stating that the variable <code>isEmpty</code> has the type: "a function from of <code>Lst a</code> to <code>Bool</code>". In Haskell, functions are <strong>pure</strong>. This means that functions behave more like mathematical functions than the functions we're used to in other programming languages. The function <code>isEmpty</code> can only use/refer to values passed to it as parameters and in its <em>context</em>, which means any variables or modules that are in scope. In this case, there's nothing in our module but the <code>isEmpty</code> function, so it has no other information other than the parameter of type <code>Lst a</code>. No other information is available to the function. Let's look at an implementation. <figure class="highlight haskell"><figcaption><span>isEmpty implementation</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"><span class="keyword">module</span> List230210 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | A datatype for lists of values</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a</span></span><br><span class="line">  = <span class="type">NIL</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | A custom implementation of a boolean like type</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Booly</span></span></span><br><span class="line">  = <span class="type">Yep</span></span><br><span class="line">  | <span class="type">Nope</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Return @Yep@ if a @Lst@ is empty, and @Nope@ otherwise</span></span><br><span class="line"><span class="title">isEmpty</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty</span> <span class="type">NIL</span> = <span class="type">Yep</span></span><br><span class="line"><span class="title">isEmpty</span> _   = <span class="type">Nope</span></span><br></pre></td></tr></table></figure></p>
<p>There are several new elements here to look at. Normally everything in <code>Prelude</code> is imported automatically, but if you recall we've explicitly excluded <code>Prelude</code> with our <code>LANGUAGE</code> directive at the top of the module, so we can redefine types and functions related to lists in this exercise. So we need to implement our own boolean type. The "official" boolean data type in Haskell is <code>Bool</code>, and our <code>Booly</code> data type is defined the same way. We've named ours differently to make it obvious we've defined our own two valued type, but that's all a boolean type is, a data type with two values, and we intuitively assign <em>semantics</em> of truth-hood and false-hood to the two data constructors <code>Yep</code> or <code>True</code>, and <code>Nope</code> or <code>False</code>.</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Finally we get to the definition of the <code>isEmpty</code>, and we see one of the key concepts in Haskell that looks very strange to those familiar with mainstream languages: pattern matching. There are two definitions of <code>isEmpty</code>. In the first, in the position of the parameter, we have the <em>data constructor</em> <code>NIL</code> from the definition of <code>Lst</code>, not a variable like we saw in the first function post, <code>mathy</code>. This causes Haskell to <em>pattern match</em> against the incoming value. If the incoming parameter has the value <code>NIL</code>, the expression evaluates to <code>Yep</code>.</p>
<p>In the second definition, there's an underscore in the parameter position. This indicates that Haskell should ignore the value in that position, any value will match the underscore. This means that if the first pattern doesn't match a <code>NIL</code>, the second pattern will match any value. For the <code>isEmpty</code> function, this is what we need. If we match <code>NIL</code>, then <code>Yep</code> the list is empty. If we match <em>anything else</em>, then <code>Nope</code> the list is not empty. That's the complete definition of <code>isEmpty</code>!</p>
<h3 id="the-type-almost-defines-the-function">The Type (almost) Defines the Function</h3>
<p>Earlier it was stated that often, especially for simple functions, there's only one way to write a function given its type. <code>isEmpty</code> is such a case. What else can we possible do with a function of type <code>Lst a -&gt; Booly</code> ? There are only two possible outputs - <code>Yep</code> and <code>Nope</code>. Since the signature specifies a <code>Lst</code> of <code>a</code> values, but it doesn't say what <code>a</code> should be, it could be anything. This is a polymorphic function with no constraints on the type variable <code>a</code>. Since we don't know what <code>a</code> is, we can't know any function that works on <code>a</code> or any of the data constructors that might be part of the definition of <code>a</code>. So in effect, the <code>a</code> tells us nothing. All we know about the parameter comes from <code>Lst</code>, and it says the value might be <code>NIL</code>, or it might be <code>Cons a (Lst a)</code>.</p>
<p>There are only four ways to define this function:</p>
<figure class="highlight haskell"><figcaption><span>Four possible ways to define iEmpty</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | the right way</span></span><br><span class="line"><span class="title">isEmpty</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty</span> <span class="type">NIL</span> = <span class="type">Yep</span></span><br><span class="line"><span class="title">isEmpty</span> _   = <span class="type">Nope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | not the right way</span></span><br><span class="line"><span class="title">isEmpty2</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty</span> <span class="type">NIL</span> = <span class="type">Nope</span></span><br><span class="line"><span class="title">isEmpty</span> _   = <span class="type">Yep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | cmon now</span></span><br><span class="line"><span class="title">isEmpty3</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty3</span> _  = <span class="type">Yep</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- | ok we&#x27;ve stopped trying</span></span><br><span class="line"><span class="title">isEmpty4</span> :: <span class="type">Lst</span> a -&gt; <span class="type">Booly</span></span><br><span class="line"><span class="title">isEmpty4</span> _  = <span class="type">Nope</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The first has the semantics we're looking for - it's consistent with the human language we're using. The second is syntactically correct, but has the wrong semantics; it has what we sometimes call a logic error. The last two are <em>constant functions</em>. They ignore their argument and always return the same value, clearly not what we're looking for. So there's only really one way to write this function!</p>
<p>🤔 ... if you're thinking there's something to the fact that there are only 4 ways to write this function, congratulations, you're paying attention. This should remind you of the discussion of algebraic types from the <a href="/2023/02/07/230207-Haskell-Basics-02/" title="Haskell Basics - Lists 01">post on lists</a>, where we said that for product types, the number of possible values for a type is the product of the number of values in each of the parameterized types. Recall that the type <code>Quiz Answer Answer</code> has 16 different possible values, since <code>Answer</code> had four possible values.</p>
<p>Our <code>Booly</code> type has two possible values. But our <code>Lst</code> type is recursive, and you can see how it might have an infinite number of values. So <code>2 * Infinity == Infinity</code>, not four. <strong>But</strong>, since we conceptually only care about the two different data constructors for <code>Lst</code>, <code>NIL</code> and <code>Cons...</code>, conceptually there are only two values to <code>Lst</code>, giving <code>2 * 2 == 4</code>, but where's the product algebraic type?</p>
<p>Recall again, this time from the <a href="/2023/02/06/230206-Haskell-Basics-01/" title="Haskell Basics - Functions 01">post on types</a>, that the arrow <code>-&gt;</code> we've been using for function definitions is a polymorphic type constructor over two types. This is easier to see when we alias the arrow and use it in a prefix way (rather than infix). That gives us this: <figure class="highlight haskell"><figcaption><span>alias the arrow type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- @type@ keyword creates an alias for a data type</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Func</span> = (-&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | Return @Yep@ if a @Lst@ is empty, and @Nope@ otherwise, now</span></span><br><span class="line"><span class="comment">--   with a type signature using the @Func@ alias for @(-&gt;)@</span></span><br><span class="line"><span class="title">isEmpty</span> :: <span class="type">Func</span> (<span class="type">Lst</span> a) <span class="type">Booly</span> </span><br><span class="line"><span class="title">isEmpty</span> <span class="type">NIL</span> = <span class="type">Yep</span></span><br><span class="line"><span class="title">isEmpty</span> _   = <span class="type">Nope</span></span><br></pre></td></tr></table></figure></p>
<p>Ah - now we see that the arrow is a type, and the two type parameters that make it a product type are the input type and the return type.If we borrow the notation <code>|T|</code> from set theory to mean the cardinality (number of values) that inhabit a type, then we see that:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|T a b| == |a| * |b|</span><br></pre></td></tr></table></figure>
<p>Where <code>T</code> is a polymorphic type over <code>a</code> and <code>b</code> which are type variables, and in the case of <code>isEmpty</code> we have <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|Func (Lst a) Booly| == |Lst a| * |Booly| == 2 * 2 == 4 </span><br></pre></td></tr></table></figure></p>
<p>If we allow that we're only considering two semantically relevant values populating <code>Lst</code>.</p>
<h4 id="so-what">So what?</h4>
<p>This is not going to help you configure your Kubernetes cluster or get all the text boxes in your div to line up correctly. Understanding things at this level is the starting point, the tip of the iceberg, to understanding the incredible relationship between computer science, logic, and abstract mathematics. Haskell is a great tool for this exploration, an exploration on which I myself have taken only a few steps. My writing these posts helps me continue to look closely at these topics, continue to have new insights, and solidify concepts.</p>
<p>Have you ever heard someone say that functional programs are "easier to reason about"? Most of the people who I've heard say this love functional programming, and know that there's <em>something</em> to it that is intuitive, that stimulates their need for things to be ordered and logical. But then there are those who have really studied and gained an understanding of abstract computer science, type theory, programming language theory, set theory, category theory, etc. or some combination of those. They think of reasoning differently.</p>
<blockquote><p><strong>reasoning (noun)</strong>: ​ the process of thinking about things in a logical way; opinions and ideas that are based on logical thinking</p>
<footer><strong>Oxford English Dictionary</strong></footer></blockquote>
<p><em>...based on logical thinking.</em> That's the key. That's what's out there to be learned.</p>
<p>Happy Hacking!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/02/11/230210-Haskell-Basics-03/" data-id="clf2y0gxj0009iwp5ee3h6t0m" data-title="Haskell Basics - Lists &amp; Functions 02" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/02/11/230210-Haskell-Basics-03/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functions/" rel="tag">functions</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-230207-Haskell-Basics-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/07/230207-Haskell-Basics-02/" class="article-date">
  <time class="dt-published" datetime="2023-02-07T07:00:00.000Z" itemprop="datePublished">2023-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/haskell/">haskell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/07/230207-Haskell-Basics-02/">Haskell Basics - Lists 01</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Lists are one of the fundamental data structures in Haskell and many other programming languages. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP</a> for example is a portmanteau of "LISt" and "Processing". The implementation of lists in Haskell is also a great way to look at a few different key features of the language that we'll discuss.</p>
<h2 id="no-implicit-prelude">No Implicit Prelude</h2>
<p>Let's do some "first principals" type experimentation. We'll create a module and tell Haskell not to import <code>Prelude</code>, which is the standard library. This will allow us to create our own list types and functions without conflicting with the ones from the standard library.</p>
<p>If you want to follow along, I suggest following these <a href="/2023/02/07/230207-GHCup/" title="Install Haskell with GHCup">installation instructions</a>. Then you can create a file with the <code>*.hs</code> extension.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGAUGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> List230207 <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>The first line is a compiler directive that excludes Prelude from being automatically imported. The other line defines a module. You can name your module any legal module name; alpha-numeric starting with a capital letter.</p>
<h1 id="a-list-type">A List Type</h1>
<p>We can define a list in Haskell like this (normally we'd use Prelude's list, this is illustrative only). In the following snippet, the <code>data</code> keyword is defining a new <em>algebraic data type</em>, <code>Lst a</code>, which has two data constructors, <code>NIL</code> and <code>Cons</code>.</p>
<figure class="highlight haskell"><figcaption><span>The Lst Type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#123;-# LANGUAGE NoImplicitPrelude #-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> List230207 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a           <span class="comment">-- names the new algebraic data type</span></span></span><br><span class="line">  = <span class="type">NIL</span>              <span class="comment">-- First data constructor, represents empty list</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)   <span class="comment">-- Second data constrctor, a value appened to an existing list</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)    <span class="comment">-- Allows conversion of Lst values to strings for display</span></span><br></pre></td></tr></table></figure>
<p>After excluding <code>Prelude</code> with the language extension, we add back in something called <code>Show</code>, which will make it easier to display values we're working with in the REPL; don't worry about the details for now.</p>
<h2 id="algebraic-data-types">Algebraic Data Types</h2>
<p>Let's break down the definition of the <code>Lst</code> type by first examining the <code>data</code> keyword, which indicates the beginning of a definition of a new <em>algebraic data type</em>. There are two kinds of algebraic data types - sum types and product types. What we've described above is a <em>sum type</em>. It's called sum because the total number of possible values is the sum of the number of values that each <em>data constructor</em> can produce. Let's look at a simple example:</p>
<figure class="highlight haskell"><figcaption><span>Example Algebraic data type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Answer</span> </span></span><br><span class="line">  = <span class="type">Yes</span> </span><br><span class="line">  | <span class="type">No</span> </span><br><span class="line">  | <span class="type">LeaningTowards</span> <span class="type">Bool</span></span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure>
<p>In this strange example, we have a data type <code>Answer</code> that has three data constructors. Two of them, <code>Yes</code> and <code>No</code>, take no parameters. The last one, <code>LeaningTowards</code> has a <code>Bool</code> parameter. This means the values, or terms, that inhabit the <code>Answer</code> data type are: <code>Yes</code>, <code>No</code>, <code>LeaningTowards True</code>, and <code>LeaningTowards False</code></p>
<p>The total number of values inhabiting <code>Answer</code> is four, which is the <em>sum</em> of the number of terms that each data constructor can produce. <code>Yes</code> and <code>No</code> can only produce one value each since they have no parameters. Intuitively they behave like values and you'll soon see how in code they're used in places where values are used, but <code>LeaningTowards</code> has a parameter of type <code>Bool</code>, which defines two data constructors (<code>True</code> and <code>False</code>), bringing to total possible values of type <code>Answer</code> to four. Algebra! Sum!</p>
<p>The other type of algebraic data type is the <em>product</em> type. An example is: <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Quiz</span> = <span class="type">Quiz</span> <span class="type">Answer</span> <span class="type">Answer</span></span></span><br></pre></td></tr></table></figure></p>
<p>The <code>data</code> keyword is the same, indicating we're introducing a new (algebraic) type. The data type is <code>Quiz</code>, and it has one data constructor, also <code>Quiz</code>. Don't be confused by the fact that the type and the one data constructor are both defined as <code>Quiz</code>, they're used in different contexts, so once the idea of types vs type constructors clicks for you, this doesn't present a problem. These are 16 possible values for the type <code>Quiz</code>:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<tbody>
<tr class="odd">
<td><code>Quiz Yes Yes</code></td>
<td><code>Quiz Yes No</code></td>
<td><code>Quiz Yes (LeaningTowards True)</code></td>
<td><code>Quiz Yes (LeaningTowards False)</code></td>
</tr>
<tr class="even">
<td><code>Quiz No Yes</code></td>
<td><code>Quiz No No</code></td>
<td><code>Quiz No (LeaningTowards True)</code></td>
<td><code>Quiz No (LeaningTowards False)</code></td>
</tr>
<tr class="odd">
<td><code>Quiz (LeaningTowards True) Yes</code></td>
<td><code>Quiz (LeaningTowards True) No</code></td>
<td><code>Quiz (LeaningTowards True) (LeaningTowards True)</code></td>
<td><code>Quiz (LeaningTowards True) (LeaningTowards False)</code></td>
</tr>
<tr class="even">
<td><code>Quiz (LeaningTowards False) Yes</code></td>
<td><code>Quiz (LeaningTowards False) No</code></td>
<td><code>Quiz (LeaningTowards False) (LeaningTowards True)</code></td>
<td><code>Quiz (LeaningTowards False) (LeaningTowards False)</code></td>
</tr>
</tbody>
</table>
<p>The one and only data constructor for <code>Quiz</code> has two parameters of type <code>Answer</code>, and we've seen that <code>Answer</code> has four possible values, therefore the product type <code>Quiz</code> has <code>4 * 4</code> or sixteen possible values. Algebra! Product!</p>
<h2 id="kinds-and-polymorphic-aka-generic-types">Kinds and Polymorphic (aka Generic) Types</h2>
<p>The <code>Quiz</code> and <code>Answer</code> are monomorphic types because they contain no type parameters. We say the <strong>kind</strong> of <code>Quiz</code> and <code>Answer</code> is <code>Type</code>. This is best illustrated with an example of a simple <em>polymorphic</em> data type: <figure class="highlight haskell"><figcaption><span>the unbiquitous Maybe type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a</span></span><br><span class="line">  = <span class="type">Nothing</span></span><br><span class="line">  | <span class="type">Just</span> a</span><br></pre></td></tr></table></figure></p>
<p>The <code>Maybe</code> type is omnipresent in functional programming languages, and some form of it is increasingly found in imperative languages as well. It's typically used to represent a value that may or may not exist. The type itself is parameterized - the <code>a</code> in the example is a <strong>type parameter</strong>. If the <strong>kind</strong> of <code>Quiz</code> is <code>Type</code>, what is the <strong>kind</strong> of <code>Maybe</code>?</p>
<p>it's <code>Type -&gt; Type</code>.</p>
<p>Knowing what we know about Haskell functions, this seems like a function that takes a type and returns a type. That's pretty much what it is. We cannot specify terms to have a type <code>Maybe</code>, because <code>Maybe</code> isn't a <code>Type</code>! it's a <code>Type -&gt; Type</code>, or a <em>higher kinded type</em>. To get a <code>Type</code> from <code>Maybe</code>, you must pass it a <code>Type</code>. For example: <figure class="highlight haskell"><figcaption><span>student quiz results</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">s1</span> :: <span class="type">Maybe</span> <span class="type">Quiz</span></span><br><span class="line"><span class="title">s1</span> = <span class="type">Just</span> (<span class="type">Quiz</span> <span class="type">Yes</span> <span class="type">No</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">s2</span> :: <span class="type">Maybe</span> <span class="type">Quiz</span></span><br><span class="line"><span class="title">s2</span> = <span class="type">Nothing</span>       <span class="comment">-- didn&#x27;t take the quiz</span></span><br><span class="line"></span><br><span class="line"><span class="title">s3</span> :: <span class="type">Maybe</span> <span class="type">Quiz</span></span><br><span class="line"><span class="title">s3</span> = <span class="type">Just</span> (<span class="type">Quiz</span> <span class="type">No</span> (<span class="type">LeaningTowards</span> <span class="type">Yes</span>))</span><br></pre></td></tr></table></figure></p>
<p>The kind of <code>Maybe Quiz</code> is <code>Type</code> which means it can be used to specify the type of the terms <code>s1</code>, <code>s2</code>, and <code>s3</code> above.</p>
<p>We see <code>Maybe</code> data constructors <code>Nothing</code> and <code>Just</code> being used here. Either a student took the quiz, represented by <code>Just ...</code> or they didn't, represented by <code>Nothing</code>.</p>
<h2 id="back-to-our-list">Back to Our List</h2>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a</span></span><br><span class="line">  = <span class="type">NIL</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)</span><br><span class="line"><span class="title">deriving</span> (<span class="type">Show</span>)</span><br></pre></td></tr></table></figure>
<p>Now that we understand algebraic data types and higher kinded types, we can see that <code>Lst</code> is kind <code>Type -&gt; Type</code>, and <code>NIL</code> and <code>Cons Lst</code> are data constructors. So far so good. <code>Lst</code> adds one more concept - a recursively defined, or <em>inductive</em> construct. The first data constructor is <code>NIL</code>, which represents an empty list. The other data constructor, <code>Cons a (Lst a)</code> is recursive; it has two parameters, the first being <code>a</code> which represents the type of values the list can contain, and it the second parameter is a value of type <code>Lst a</code>, another list. Lets look at an example of using our <code>Lst</code> type. <figure class="highlight haskell"><figcaption><span>Lst Example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> List230207 <span class="keyword">where</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Prelude (<span class="type">Show</span>, <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lst</span> a</span></span><br><span class="line">  = <span class="type">NIL</span></span><br><span class="line">  | <span class="type">Cons</span> a (<span class="type">Lst</span> a)</span><br><span class="line">  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">nums</span> :: <span class="type">Lst</span> <span class="type">Int</span></span><br><span class="line"><span class="title">nums</span> = <span class="type">Cons</span> <span class="number">1</span> (<span class="type">Cons</span> <span class="number">2</span> (<span class="type">Cons</span> <span class="number">3</span> <span class="type">NIL</span>))</span><br></pre></td></tr></table></figure></p>
<p>In this example <code>nums</code> is a <code>Lst Int</code> , or a list of integers. I've included <code>Int</code> in the list of identifiers being imported from Prelude so we could specify the type parameter for <code>Lst</code> to be specifically <code>Int</code>. Noticed how we declare constants in a similar way that we declare functions, the type specification comes before the assignment (see this post on <a href="/2023/02/06/230206-Haskell-Basics-01/" title="Haskell Basics - Functions 01">functions for more info</a>). This is effectively how Haskell's standard library implements the list type, only since lists are so common and heavily used, there's some syntactic sugar in Haskell syntax that makes working with lists much more bearable and intuitive. We'll see these later, but our definition is definitely a valid way to represent lists.</p>
<p>So now that we've got a list defined ... we need to do something with it. Next time we'll work with our list type in creating some functions you typically use with lists - things like getting the length, appending one list to another, and mapping values in a list using a function to create a new list.</p>
<p>Happy Hacking!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/02/07/230207-Haskell-Basics-02/" data-id="clf2y0gxh0006iwp5fek9bt4h" data-title="Haskell Basics - Lists 01" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/02/07/230207-Haskell-Basics-02/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-structures/" rel="tag">data-structures</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/induction/" rel="tag">induction</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-230207-GHCup" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/07/230207-GHCup/" class="article-date">
  <time class="dt-published" datetime="2023-02-07T06:00:00.000Z" itemprop="datePublished">2023-02-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/haskell/">haskell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/07/230207-GHCup/">Install Haskell with GHCup</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>A quick and easy way to get Haskell set up and keep it up to date is to use <a target="_blank" rel="noopener" href="https://www.haskell.org/ghcup/">GHCup</a>. Follow the link for directions. GHCup will install a few different components. Haskell has a history of what is, by modern standards, poor tooling. It's not a new language, Haskell was developed in the early 90s, and for the first couple of decades of its existence was mostly an academic programming language, and it shows.</p>
<p>Things are far better now, but not quite as slick as Golang or Rust's ecosystems which have the benefit of being recently developed with contemporary thinking about tooling and package management. Here's some initial guidance.</p>
<h2 id="ghc---glasgow-haskell-compiler"><a target="_blank" rel="noopener" href="https://www.haskell.org/ghc/">GHC</a> - Glasgow Haskell Compiler</h2>
<p>The open source compiler for Haskell. Technically this is just <em>one</em> of the Haskell compilers available, as the intent of Haskell was to be a specification and not an implementation, thereby not locking anyone into a single compiler.</p>
<p>The reality is that most people are using GHC, and that most experimentation and expansion of the Haskell specification is happening in GHC. It's considered the most advanced Haskell compiler and to make your life simpler, just go with GHC and forget that there are other choices, until you find a compelling reason to do so.</p>
<h2 id="cabal">Cabal</h2>
<p>The standard package system for Haskell software, and for the longest time was <strong>the</strong> way to build Haskell programs, find and download packages, and build and publish packages. Many people still use Cabal, and it's not too bad. I personally don't I use the next tool in the list.</p>
<h2 id="stack">Stack</h2>
<p>aka The <a target="_blank" rel="noopener" href="https://docs.haskellstack.org/en/stable/">Haskell Tool Stack</a>, it's a program for working with Haskell projects, and is a bit more modern in its approach. This is the approach I use, and while <em>still</em> not perfect, it's at least somewhat reasonable, and once you establish a practice it's trivial to use Stack for package and product management. Stack actually leverage Cabal internally to do the actual work of package management, so the're reasonably compatible and interchangeable.</p>
<h2 id="hls"><a target="_blank" rel="noopener" href="https://haskell-language-server.readthedocs.io/en/stable/">HLS</a></h2>
<p>The Haskell Language Server, an implementation of the <a target="_blank" rel="noopener" href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a> for Haskell. The Language Server Protocol, or LSP, defines a protocol use between an editor or IDE and a language server that provides language features like auto complete, go to definition, find all references, etc.. For a long time (and this is where the poor tooling rep was spot on), you would have a hard time working with Haskell outside of Emacs. With the HLS, we get a decent language aware IDE from VSCode, and many other editors that are now LSP aware.</p>
<h1 id="using-the-repl">Using the REPL</h1>
<p>Once you've got the Haskell tooling installed and before you get involved with setting up a full project with either Stack or Cabal, to get your feet wet you can use the REPL combined with a single Haskell file like this: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># create your source file</span></span><br><span class="line">$ <span class="built_in">touch</span> scratch.hs  <span class="comment"># or whatever you want to call it</span></span><br><span class="line">$ stack repl scratch.hs</span><br></pre></td></tr></table></figure></p>
<p>This starts the REPL. You'll see a prompt <code>Prelude&gt;</code>, indicating you've got the REPL with Prelude (the standard library), and your file is loaded (even if it's empty). From here, you can use a few of these handy REPL commands:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>Purpose</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:?</code></td>
<td>Get help on all the commands</td>
<td></td>
</tr>
<tr class="even">
<td><code>:quit</code></td>
<td>Quit the repl</td>
<td></td>
</tr>
<tr class="odd">
<td><code>:type</code></td>
<td>Output the type of the term or expression</td>
<td><code>Prelude&gt; :t [1,2,3]</code></td>
</tr>
<tr class="even">
<td><code>:kind</code></td>
<td>Get the <em>kind</em> of a <code>Type</code></td>
<td><code>Prelude&gt; :k Maybe</code></td>
</tr>
<tr class="odd">
<td><code>:edit</code></td>
<td>Opens the currently loaded file (scratch.hs in our example) in the default editor. Saving and quitting the editor will reload the file in the REPL</td>
<td></td>
</tr>
<tr class="even">
<td><code>:reload</code></td>
<td>Reloads the currently loaded file. You can have an editor open on the file in the REPL, and iterate on the file, saving it each time. Then use the <code>:r</code> command in the REPL to load the latest save</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="editing-your-file">Editing Your File</h2>
<p>The REPL is handy of course for trying things out. But since it's only one line at a time (there's a kind of multi-line ability but it's not great), it's handy to have a file in your REPL session. You can either keep the file open in your favorite editor and iterate over it making changes, and periodically reload into the REPL with the <code>:r</code> command, or you can use the <code>:e</code> command to fire up your default editor (VIM in my case) make edits, and when you save/quit, the REPL will automatically reload your source file.</p>
<p>That's the basics... Happy Hacking!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/02/07/230207-GHCup/" data-id="clf2y0gxg0005iwp54l5r4tgy" data-title="Install Haskell with GHCup" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/02/07/230207-GHCup/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/setup/" rel="tag">setup</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-230206-Haskell-Basics-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/06/230206-Haskell-Basics-01/" class="article-date">
  <time class="dt-published" datetime="2023-02-06T05:00:00.000Z" itemprop="datePublished">2023-02-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/haskell/">haskell</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/06/230206-Haskell-Basics-01/">Haskell Basics - Functions 01</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>The syntax for function definition in Haskell is different from most other programming languages, especially mainstream programming languages. Let's take a look at a simple function.</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | Perform math operation on two integers</span></span><br><span class="line"><span class="title">mathy</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">mathy</span> m n = (m * <span class="number">10</span>) + n</span><br></pre></td></tr></table></figure>
<p>If you're new to Haskell this will look very strange. The first thing to notice is that the first line (after the comment) is the type declaration for the function. A variable <code>mathy</code> is going to be bound to the definition of this function. In Haskell once a variable is bound it cannot be changed. In Haskell values are immutable and once a variable is bound to a variable, including functions, they cannot be altered.</p>
<p>The double colon <code>::</code> is how we define <em>type signatures</em>, so the first line says that <code>mathy</code> has the type <code>Int -&gt; Int -&gt; Int</code>, which we can think of as the type signature of a function. in this case there are 3 parts separated by right arrows <code>-&gt;</code>. Using conventional terminology, you might say that each part is a parameter of the function except the last, which is the return value of the function. Therefore we can say that <code>mathy</code> takes two <code>Int</code> parameters and returns an <code>Int</code> value.</p>
<p>The next line is the definition. The variable bound to the function is separated by its parameters by whitespace. <code>m</code> and <code>n</code> are the parameters of the function. The "body" of the function is the expression after the equal sign, <code>(m * 10) + n</code>.</p>
<h2 id="calling-functions">Calling Functions</h2>
<p>Once the function is defined it can be called with parameters to return a value. <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; mathy <span class="number">21</span> <span class="number">5</span></span><br><span class="line"><span class="number">215</span></span><br><span class="line"></span><br><span class="line">&gt; mathy <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">88</span></span><br></pre></td></tr></table></figure></p>
<h2 id="arrow---the-type-of-functions">Arrow - The Type of Functions</h2>
<p>Aside from the different syntax we've just seen, the first real big significant difference between Haskell and most other languages is that the arguments are simply listed after the function name; no parentheses or commas.</p>
<h3 id="partial-application">Partial Application</h3>
<p>More significantly, we can call a function without passing <em>all the arguments</em> to the function. Let's take a look at the function, it's type, and the types of values that come from calling the function in different ways. Note the command <code>:type</code> at the REPL returns the type (it can be abbreviated <code>:t</code>).</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">-- the type of the function bound to mathy</span></span><br><span class="line">&gt; :t mathy</span><br><span class="line"><span class="title">mathy</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">-- callng with one parameter</span></span><br><span class="line">&gt; :t mathy <span class="number">8</span></span><br><span class="line"><span class="title">mathy</span> <span class="number">8</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="comment">-- calling the all parameters</span></span><br><span class="line">&gt; :t mathy <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="title">mathy</span> <span class="number">8</span> <span class="number">4</span> :: <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>You should be seeing the pattern here. Arrow <code>-&gt;</code> is actually a polymorphic type constructor, in some other languages called a generic type. Specifically it's a generic type in two type variables, the input (on the left of the arrow) and the output (on the right of the arrow). In C#, the type of anonymous functions is <code>Func&lt;T,TReturn&gt;</code>, a polymorphic type in two type variables, the first <code>T</code> is the type of input, and the second <code>TReturn</code> is the type of output. Java has a similar generic type for anonymous functions.</p>
<h3 id="infix">Infix</h3>
<p>Haskell has the notion of <em>infix</em> operators, and that's what <code>-&gt;</code> is, an <em><strong>infix</strong></em> <em>polymorphic type constructor</em>. Functions and type constructors are typically post fix; the arguments go after the function name. Infix works like the plus sign, which represents the addition function. The plus sits between the two numbers being added. Haskell lets us define functions, and type constructors, as infix.</p>
<p>We could define our <code>mathy</code> function that's infix: <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | An infix version of mathy</span></span><br><span class="line">(++++) :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line">(++++) m n = (m * <span class="number">10</span>) + n</span><br></pre></td></tr></table></figure></p>
<p>Then it could be called infix style, like you would addition: <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">8</span> ++++ <span class="number">5</span></span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p>
<p>You can also call non symbolic functions in an infix style by surrounding it with back tick characters. <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- infix calling of mathy</span></span><br><span class="line">&gt; <span class="number">8</span> `mathy` <span class="number">5</span></span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure></p>
<p>We can see that <code>-&gt;</code> is a type constructor by assigning an alias that's not symbolic. We'll use the same name as the C# type for anonymous functions. <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- | create a type that&#x27;s an alias for arrow</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Func</span> = (-&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- | using Func to define a function. It has the same type</span></span><br><span class="line"><span class="comment">--   as mathy, so we can assign it directly</span></span><br><span class="line"><span class="title">mathy2</span> :: <span class="type">Func</span> <span class="type">Int</span> (<span class="type">Func</span> <span class="type">Int</span> <span class="type">Int</span>)</span><br><span class="line"><span class="title">mathy2</span> = mathy</span><br></pre></td></tr></table></figure></p>
<p>It's now even more clear that <code>mathy2</code>, like <code>mathy</code> is actually a function that takes an integer and produces a function that takes an integer and produces an integer. We can do this:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; mathyOfEight = mathy <span class="number">8</span></span><br><span class="line"><span class="title">mathyOfEight</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">&gt; mathyOfEight <span class="number">5</span></span><br><span class="line"><span class="number">85</span></span><br><span class="line"></span><br><span class="line">&gt; mathy <span class="number">8</span> <span class="number">5</span> == mathyOfEight <span class="number">5</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>
<p>We've seen that in Haskell a function is defined using a type signature, and a function body. We've seen the Haskell arrow <code>-&gt;</code> type, which is the type of functions, and we've seen how we can partially apply functions to create new functions with fewer arguments. A future post will get into a bit more of the syntax of functions in Haskell.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/02/06/230206-Haskell-Basics-01/" data-id="clf2y0gxf0004iwp50qwe6nzo" data-title="Haskell Basics - Functions 01" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/02/06/230206-Haskell-Basics-01/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functions/" rel="tag">functions</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-230205-Fresh-Start" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/05/230205-Fresh-Start/" class="article-date">
  <time class="dt-published" datetime="2023-02-05T18:00:00.000Z" itemprop="datePublished">2023-02-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/misc/">misc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/02/05/230205-Fresh-Start/">A Fresh Start</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>I'm restarting this blog after several years of inattention. I've rebooted a few times over the years, but failed in the past to keep it up. Now I feel the need to capture my experiences, interests, and path of further education, for my own sake. I look to this as a purpose where before I can't say I had one. So with this in mind, off I go.</p>
<h2 id="parting-with-the-past">Parting with the Past</h2>
<p>I have a few posts from the past, most of which are more than 12 years old. In previous reboots I incorporated those post in new versions of this blog. Some of them are still interesting, possibly even relevant. But I've changed significantly in the last dozen years. Connecting my thoughts of 12+ years ago with my current thinking seems feels forced. I'm no longer intrigued by the possibility or writing multi-threaded algorithms for the browser in Silverlight!</p>
<p>So with that I'm putting all those articles into an archive. This with be the new oldest post. The new, Fresh Start.</p>
<h1 id="areas-of-interest">Areas of Interest</h1>
<p>There are many. Too many. It's a wonderful problem to have. I sit in my den on a Sunday morning, put a playlist from the <a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCS7CucNrX3f6JCuIj_ugZpA">Total Baroque</a> channel on the entertainment system, and have to choose what to spend the next few hours studying, practicing, writing. Today I'm getting this blog back on its feet; consider that area of interest #1.</p>
<p>I'm using <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> to generate the blog because I wanted a simple static site generator that allows the authoring of posts using straight markdown. My posts won't be locked into a too-proprietary system. I use <a target="_blank" rel="noopener" href="https:/obsidian.md">Obsidian</a> heavily for notes, and I can set up the source for my blog to also be an Obsidian "vault", allowing me to work on blog posts with the same tools that I use all the time for other purposes. In the past I've used blog systems that were also tied to my current interest... but as interests change, so did my desire to keep up with whatever esoteric blogging approach I was using. Hexo is a node based system, simple to set up and use and, importantly, simple to come back to and be able to continue using without having to remember a series of bespoke incantations. Let's see how long this lasts.</p>
<h2 id="functional-programming">Functional Programming</h2>
<p>What a broad topic. I've got to take this back to about 2006. Around this time (I'm not going to look up specific dates) I was working as an independent contractor / consultant sub-contracting under Microsoft Consulting, building a system for the Pinellas county tax collector in Clearwater Florida. It was Microsoft stack, C# specifically, a distributed system, "thick" client (what we called native apps at the time) using <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Distributed_Component_Object_Model">DCOM</a>, a now obsolete distributed networking stack.</p>
<h3 id="c-gets-linq">C# gets Linq</h3>
<p>Around this time Microsoft added <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Language_Integrated_Query">Linq</a> to C# and the .NET ecosystem. Linq is marketing speak for a combination of runtime, language, and library extensions that "<em>adds native data querying capabilities to .NET languages</em>". This amounted to adding anonymous functions to C#, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Extension_method#">extension methods</a>, and an abstraction called <code>IEnumerable</code> that make it reasonably intuitive to write and compose functions we'd now recognize as building on maps and folds.</p>
<p>This was a bit shocking and revolutionary at a time when "functional" concepts had not yet started to become ubiquitous in the most popular OO ecosystems, Java and .NET. I remember specifically working with <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/maresca/">Jerry Maresca</a>, one of the senior engineers from Microsoft (with whom I greatly enjoyed working), hungrily consuming these new capabilities and libraries, and experimenting with the new approaches to both low level algorithm implementations, but also what this meant for the structure and organization of entire programs. Object Oriented programming had been the norm for "line of business" programming since the late 80s / early 90s.</p>
<p>Linq and the associated technologies and libraries squeezed functional concepts (which interestingly enough is not a term that has a single, well accepted defintion), into what remains to this day a <em>very</em> object oriented ecosystem. As we began to see the elegance and utility of thinking of problems in terms of functions, functional composition, and data structures uncoupled from the functions by which they are manipulated (ie <em>methods</em>). This is directly at odds with object oriented thinking, and we did some <em>strange</em> experiments combining these paradigms using these early tools.</p>
<p>But the real benefit for me was to open my eyes to the possibility of significantly different ways to think about computing at all levels. In short, I thought I had fairly complete knowledge of the landscape of production software engineering and computer programming, and to realize how wrong I was about that was captivating and exciting!</p>
<h2 id="a-pivotal-discussion-over-lunch">A Pivotal Discussion over Lunch</h2>
<p>A couple of years later, working again with Microsoft Consulting with <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/stcohen/">Stephen Cohen</a> (Chief Architect at Microsoft), this time for the Department of State in DC, I was at lunch with Stephen and <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/ggmiller12345/">Randy Miller</a>. The topic of Lisp came up, at the time i was aware of lisp, but had failed to have any interest in a language that was outside of the ecosystem in which I was immersed. Randy made a compelling argument supporting his admiration and appreciation for lisps which piqued my curiosity.</p>
<p>Over the next weeks during frequent visits to the local Borders where several of us on that gig would hang out in evenings (we were "on the road" in DC from all over the country for this gig), I began seeking out and reading about Lisps and other languages. I wandered the field and eventually came across OCaml, and after playing with it a bit and gaining interest, fell upon a research project being worked on by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don_Syme">Don Syme</a> of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Microsoft_Research">Microsoft Research</a>, a discovery that would radically alter the course of my journey.</p>
<h2 id="f">F#</h2>
<p>Don Syme was developing <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/F_Sharp_(programming_language)">F#</a>, a descendant of OCaml for the .NET framework at around the time I was having that lunch with Stephen and Randy. F# was still a couple of years away from production ready release, but you could get your hands on the compiler from the Microsoft Research site, and with some fiddling you could actually use it in an ecosystem (.NET) which was rich enough to make the endeavor worth while.</p>
<p>This was a major tipping point for me. I was now obsessed with this new way of thinking about writing software. I'd eventually come to understand that functional programming wasn't new at all, and importantly, function programming opens the door to a universe of cross disciplinary thought. I spent several years of using F# on my own time, and also building an appreciation for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Clojure">Clojure</a> (a JVM lisp), but never having the opportunity to use either professionally. That would change when I was cold contacted by <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/aimeegerzofsky/">Aimee Gerzofsky</a> a recruiter at <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Jet.com">Jet.com</a>.</p>
<p>Jet.com was an e-commerce startup, pre-launch in 2015. The interesting part - they were an F# shop! This was 90% of the reason I would eventually join Jet and move to the NY area. I was working <strong>full time in a functional programming language</strong>. This was then and remains now far and away the best job I've ever had. I was being paid to spend thousands of hours over the next few years writing code that I would have been writing on my own time. F# remains a favorite of mine, though my current interests have moved on to find and probe the more exotic regions of the computer science landscape.</p>
<h1 id="haskell">Haskell</h1>
<p>A few years later I found myself with a deep interest in Haskell. I had taken a few shots at learning Haskell (which happens to many I've since learned), giving up and returning to the familiar, comfortable lands of F#, Clojure, and OCaml, before it finally started to click for me. This corresponded to a push toward management in my career.</p>
<p>This "push" was not driven by my interests, but rather that of the companies for whom I worked. This is common for software engineers as they hit the 10, 15, 20 year marks in their career. Companies will place a hand firmly in the small of your back and shove you into management, where your skills will immediately start to fade as thoughts of budgets, timelines, recruiting, career planning, and most disruptively, the authoring and delivery of endless power point presentations take the time you'd rather spend writing beautiful code. Sigh.</p>
<p>Most of my spare time was spent diligently building my intuition for the pure functional world of Haskell. This is an ongoing endeavor to this day. Haskell is my favorite general purpose programming language, and once again I find myself fixated on technologies that I will very likely never have the opportunity to work on professionally; this serves only to motivate me further.</p>
<h1 id="gödel-escher-bach">Gödel, Escher, Bach</h1>
<p>In the last several years, starting in approximately 2018, I crossed paths with several topics that were not obviously connected with my interest in functional programming. I received a copy of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">Gödel, Escher, Back</a> (Hofstadter, 1979) (G.E.B.) from my family as a birthday or Christmas gift (I forget which), it had been on my wish list for some time. I knew nothing about it other than it appeared on the must read lists of several people I admired or followed.</p>
<p>Around the same time, I had come across <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Philip_Wadler">Phil Wadler's</a> <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=IOiZatlZtGU">Propositions as Types</a> talk from Strange Loop 2015, which broke my brain. Wadler was talking about something that was obviously profound and fascinating, and I didn't understand 25% of it. But the fuse was once again lit for me. There was a connection between logic (which I knew nothing about), and computer science, and it was fascinating... more to come.</p>
<p>Also around the same time, my daughter was at Kenyon College studying philosophy and the classics. She had taken a course on Propositional Logic, and in chatting about it I came to realize that the topic had much overlap with the boolean logic that's a deep and integral aspect of computer programming. Add propositional logic to the list of topics in which I suddenly found myself deeply interested.</p>
<h3 id="all-things-connected">All Things Connected</h3>
<p>Between the beginning of my studying G.E.B., discovering the idea of Proposition as Types, opening a line of studying of propositional logic, and all of the studying of functional programming I've done over several years, I came to understand the underpinnings of all these topics are related. Abstract Mathematics. Another shocking discovery for me - mathematics, a topic for which I would regularly declare an unabashed disdain for my entire life until this point, had stealthily worked it's way into my academic life to suddenly spring forth and become the center of my universe. I had to, and still have to suppress the feeling that had I come to this realization 30 years sooner, I would be in a very different place indeed. Such, as they say, is life.</p>
<h3 id="the-academics">The Academics</h3>
<p>Which brings me, finally, to the remainder of the list of my interests. They include, but are not limited to:</p>
<ul>
<li>Type Theory
<ul>
<li>Dependent type theory</li>
<li>Linear types</li>
</ul></li>
<li>Category Theory</li>
<li>Set Theory</li>
<li>Formal Verification
<ul>
<li>Calculus of Constructors</li>
<li>Logic</li>
<li>Coq, Agda, Idris, and most recently Lean4</li>
<li>TLA+</li>
</ul></li>
<li>Compiler Design
<ul>
<li>The various flavors of Lambda Calculus &amp; Combinators</li>
</ul></li>
<li>Programming Language Theory</li>
</ul>
<p>This challenge I now face regularly; spending enough time with each of these topics to retain what I've learned, while pushing forward the boundaries of my own knowledge one area at a time. Again, this is a really nice problem to have.</p>
<p>My journey continues.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://efvincent.github.io/2023/02/05/230205-Fresh-Start/" data-id="clf2y0gxc0001iwp5f2c9h3gs" data-title="A Fresh Start" class="article-share-link">Share</a>
      
        <a href="http://efvincent.github.io/2023/02/05/230205-Fresh-Start/#disqus_thread" class="article-comment-link">Comments</a>
      
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/haskell/">haskell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/basics/" rel="tag">basics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structures/" rel="tag">data-structures</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functions/" rel="tag">functions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/haskell/" rel="tag">haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/induction/" rel="tag">induction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setup/" rel="tag">setup</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/basics/" style="font-size: 20px;">basics</a> <a href="/tags/data-structures/" style="font-size: 10px;">data-structures</a> <a href="/tags/functions/" style="font-size: 15px;">functions</a> <a href="/tags/haskell/" style="font-size: 20px;">haskell</a> <a href="/tags/induction/" style="font-size: 10px;">induction</a> <a href="/tags/setup/" style="font-size: 10px;">setup</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/09/230217-Haskell-Basics-04/">Haskell Basics - Lists &amp; Functions 03</a>
          </li>
        
          <li>
            <a href="/2023/02/11/230210-Haskell-Basics-03/">Haskell Basics - Lists &amp; Functions 02</a>
          </li>
        
          <li>
            <a href="/2023/02/07/230207-Haskell-Basics-02/">Haskell Basics - Lists 01</a>
          </li>
        
          <li>
            <a href="/2023/02/07/230207-GHCup/">Install Haskell with GHCup</a>
          </li>
        
          <li>
            <a href="/2023/02/06/230206-Haskell-Basics-01/">Haskell Basics - Functions 01</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Eric Vincent<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'efvincent-blog-1';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.async = true;
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>